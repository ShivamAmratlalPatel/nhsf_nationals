import random

from django import forms

from ..models import FootballPitch, FootballSchedule, FootballTable, \
    FootballTeam, FootballKnockout
from django.core.exceptions import BadRequest
from django.db.models import Q


def generate_schedule() -> None:
    """
    Generate the football schedule.

    The schedule is generated by:
    1. Each team plays every other team in their group
    2. There should be no more than 2 games in a row for a team
    """
    # If schedule already exists then don't generate it
    if FootballSchedule.objects.all().exists():
        return

    teams = FootballTeam.objects.all().order_by("group", "name").values(
        "team_id", "group")

    # Generate fixtures for each group
    for group in teams.values("group").distinct():
        group_teams = list(teams.filter(group=group["group"]))

        # Generate fixtures for each team
        for team in group_teams:
            # Generate fixtures for each opponent
            for opponent in group_teams:
                # Don't generate a fixture for the team playing themselves
                if team["team_id"] != opponent["team_id"]:
                    # If the fixture doesn't already exist create it
                    if not FootballSchedule.objects.filter(
                            Q(team_id=team["team_id"]) & Q(
                                opponent_id=opponent["team_id"])).exists():
                        # If the fixture doesn't already exist the other way around
                        # create it
                        if not FootballSchedule.objects.filter(
                                Q(team_id=opponent["team_id"]) & Q(
                                    opponent_id=team["team_id"])).exists():
                            FootballSchedule.objects.update_or_create(
                                team_id=team["team_id"],
                                opponent_id=opponent["team_id"])

    # Randomly assign pitches and times to fixtures
    pitches = FootballPitch.objects.all().order_by("name")
    pitches_count = pitches.count()

    fixtures = FootballSchedule.objects.filter(played=False).order_by(
        "team_id").values("schedule_id", "team__group")

    for index, fixture in enumerate(fixtures):
        if fixture["team__group"] <= 3:
            pitch = index % pitches_count + 1
        else:
            pitch = random.randint(1, pitches_count)
        time = random.randint(0, 23)
        FootballSchedule.objects.filter(schedule_id=fixture["schedule_id"]).update(
            pitch=pitch,
            time=f"{time}:00:00")


def initalise_football_table() -> None:
    """Initalise the football table"""

    current_table = FootballTable.objects.all()

    teams = FootballTeam.objects.all().values("team_id")

    for team in teams:
        if not current_table.filter(team_id=team["team_id"]).exists():
            FootballTable.objects.update_or_create(team_id_id=team["team_id"],
                                                   played=0,
                                                   won=0,
                                                   drawn=0,
                                                   lost=0,
                                                   goals_for=0,
                                                   goals_against=0,
                                                   goal_difference=0,
                                                   points=0,
                                                   points_per_game=0)


def get_football_schedule() -> dict:
    """Return a dict of football schedules by pitches"""

    # If schedule is empty, initalise it
    if not FootballSchedule.objects.all().exists():
        generate_schedule()

    initalise_football_table()

    schedule = FootballSchedule.objects.select_related(
        "pitch").all().order_by(
        "time").values("pitch__name", "team__name", "opponent__name",
                       "team_score", "opponent_score", "time", "played")
    pitches = FootballPitch.objects.all().values("name")
    output = {pitch["name"]: [] for pitch in pitches}

    [output[game["pitch__name"]].append(
        {"game": f"{game['team__name']} vs {game['opponent__name']}",
         "time": game["time"].strftime("%H:%M"),
         "result": f"{game['team_score']} - {game['opponent_score']}",
         "played": game["played"]})
        for game in
        schedule]

    return output


def get_football_table() -> dict:
    """Return a dict of football table"""

    table = FootballTable.objects.all().select_related(
        "team_id").order_by("-points", "-goal_difference",
                            "-goals_for",
                            "-played").values("team_id__name",
                                              "team_id__group", "played",
                                              "won",
                                              "drawn", "lost",
                                              "goals_for", "goals_against",
                                              "goal_difference",
                                              "points")

    groups = FootballTeam.objects.all().values("group").distinct().order_by(
        "group")

    output = {group["group"]: [] for group in groups}

    [output[team["team_id__group"]].append(
        {"team": team["team_id__name"],
         "played": team["played"],
         "won": team["won"],
         "drawn": team["drawn"],
         "lost": team["lost"],
         "goals_for": team["goals_for"],
         "goals_against": team["goals_against"],
         "goal_difference": team["goal_difference"],
         "points": team["points"]})
        for team in table]

    return output


def update_football_table(team_id: int) -> None:
    """
    Update the football table.

    :param team_id: The team ID to update the table for
    :return: The updated football table
    """
    if not team_id:
        raise BadRequest("Team ID is required")

    # If team id is not in table then initialise table
    if not FootballTable.objects.filter(team_id=team_id).exists():
        initalise_football_table()

    team_results = FootballSchedule.objects.filter(
        Q(team_id=team_id) | Q(opponent_id=team_id)).filter(
        played=True).values("team_id",
                            "opponent_id",
                            "team_score",
                            "opponent_score")

    games_played = len(team_results)
    games_won = 0
    games_drawn = 0
    games_lost = 0
    goals_for = 0
    goals_against = 0

    for result in team_results:
        if result["team_id"] == team_id:
            goals_for += result["team_score"]
            goals_against += result["opponent_score"]
            if result["team_score"] > result["opponent_score"]:
                games_won += 1
            elif result["team_score"] < result["opponent_score"]:
                games_lost += 1
            else:
                games_drawn += 1
        else:
            goals_for += result["opponent_score"]
            goals_against += result["team_score"]
            if result["team_score"] < result["opponent_score"]:
                games_won += 1
            elif result["team_score"] > result["opponent_score"]:
                games_lost += 1
            else:
                games_drawn += 1

    goal_difference = goals_for - goals_against
    points = games_won * 3 + games_drawn

    FootballTable.objects.update_or_create(team_id=team_id,
                                           defaults={"played": games_played,
                                                     "won": games_won,
                                                     "drawn": games_drawn,
                                                     "lost": games_lost,
                                                     "goals_for": goals_for,
                                                     "goals_against":
                                                         goals_against,
                                                     "goal_difference":
                                                         goal_difference,
                                                     "points": points,
                                                     "points_per_game": points / games_played})

    return


def get_unplayed_football_games() -> list:
    """Return a list of unplayed football games with the format [(schedule_id, game)]"""

    games = FootballSchedule.objects.filter(played=False).order_by("pitch",
                                                                   "time").values(
        "schedule_id",
        "team__name",
        "opponent__name",
        "pitch__name")

    return [(game["schedule_id"],
             f"{game['pitch__name']}: {game['team__name']} vs {game['opponent__name']}")
            for
            game in games]


class UnplayedGamesForm(forms.Form):
    """Form to validate unplayed games"""
    choices = get_unplayed_football_games()
    game = forms.ChoiceField(label="Game", choices=choices)
    team_1_score = forms.IntegerField(label="Team 1 Goals")
    team_2_score = forms.IntegerField(label="Team 2 Goals")


def log_football_score(schedule_id: int, home_score: int,
                       away_score: int) -> None:
    """Log a football score"""

    if not schedule_id:
        raise BadRequest("Schedule ID is required")

    if not home_score:
        raise BadRequest("Home score is required")

    if not away_score:
        raise BadRequest("Away score is required")

    FootballSchedule.objects.filter(schedule_id=schedule_id).update(
        team_score=home_score,
        opponent_score=away_score,
        played=True)

    update_football_table(FootballSchedule.objects.get(
        schedule_id=schedule_id).team_id)
    update_football_table(FootballSchedule.objects.get(
        schedule_id=schedule_id).opponent_id)

    return


def generate_knockout_teams() -> None:
    """
    Generate the knockout teams.

    If the knockout table already exists it should not generate it.

    If the group stages have not all finished it should not generate it.

    It should pick the top team from each league and then pick the next best teams
    from any league based on highest average points per game played until there are 8
    teams. It should then order these teams based on average points per games and then
    top team should play worst team and so on.

    :return: None
    """

    if FootballKnockout.objects.exists():
        return

    if FootballTable.objects.filter(played=False).exists():
        return

    # Get top team from each group
    top_teams = FootballTable.objects.all().order_by("-points_per_game",
                                                     "-goal_difference",
                                                     "-goals_for").values(
        "team_id__name", "team_id__group")

    # Get top 8 teams based on average points per game played
    top_teams = top_teams[:8]

    # Order teams based on average points per game played
    top_teams = sorted(top_teams, key=lambda x: x["points_per_game"],
                       reverse=True)

    # Create knockout table
    [FootballKnockout.objects.create(team_id=FootballTeam.objects.get(
        name=team["team_id__name"]).team_id,
                                     group=team["team_id__group"])
     for team in top_teams]

    return
